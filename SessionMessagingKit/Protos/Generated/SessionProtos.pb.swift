// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: SessionProtos.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

/// iOS - since we use a modern proto-compiler, we must specify the legacy proto format.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct SessionProtos_Envelope {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var type: SessionProtos_Envelope.TypeEnum {
    get {return _type ?? .sessionMessage}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  var source: String {
    get {return _source ?? String()}
    set {_source = newValue}
  }
  /// Returns true if `source` has been explicitly set.
  var hasSource: Bool {return self._source != nil}
  /// Clears the value of `source`. Subsequent reads from it will return its default value.
  mutating func clearSource() {self._source = nil}

  var sourceDevice: UInt32 {
    get {return _sourceDevice ?? 0}
    set {_sourceDevice = newValue}
  }
  /// Returns true if `sourceDevice` has been explicitly set.
  var hasSourceDevice: Bool {return self._sourceDevice != nil}
  /// Clears the value of `sourceDevice`. Subsequent reads from it will return its default value.
  mutating func clearSourceDevice() {self._sourceDevice = nil}

  /// @required
  var timestamp: UInt64 {
    get {return _timestamp ?? 0}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {self._timestamp = nil}

  var content: Data {
    get {return _content ?? Data()}
    set {_content = newValue}
  }
  /// Returns true if `content` has been explicitly set.
  var hasContent: Bool {return self._content != nil}
  /// Clears the value of `content`. Subsequent reads from it will return its default value.
  mutating func clearContent() {self._content = nil}

  var serverTimestamp: UInt64 {
    get {return _serverTimestamp ?? 0}
    set {_serverTimestamp = newValue}
  }
  /// Returns true if `serverTimestamp` has been explicitly set.
  var hasServerTimestamp: Bool {return self._serverTimestamp != nil}
  /// Clears the value of `serverTimestamp`. Subsequent reads from it will return its default value.
  mutating func clearServerTimestamp() {self._serverTimestamp = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum TypeEnum: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case sessionMessage // = 6
    case closedGroupMessage // = 7

    init() {
      self = .sessionMessage
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 6: self = .sessionMessage
      case 7: self = .closedGroupMessage
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .sessionMessage: return 6
      case .closedGroupMessage: return 7
      }
    }

  }

  init() {}

  fileprivate var _type: SessionProtos_Envelope.TypeEnum? = nil
  fileprivate var _source: String? = nil
  fileprivate var _sourceDevice: UInt32? = nil
  fileprivate var _timestamp: UInt64? = nil
  fileprivate var _content: Data? = nil
  fileprivate var _serverTimestamp: UInt64? = nil
}

#if swift(>=4.2)

extension SessionProtos_Envelope.TypeEnum: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct SessionProtos_TypingMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var timestamp: UInt64 {
    get {return _timestamp ?? 0}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {self._timestamp = nil}

  /// @required
  var action: SessionProtos_TypingMessage.Action {
    get {return _action ?? .started}
    set {_action = newValue}
  }
  /// Returns true if `action` has been explicitly set.
  var hasAction: Bool {return self._action != nil}
  /// Clears the value of `action`. Subsequent reads from it will return its default value.
  mutating func clearAction() {self._action = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Action: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case started // = 0
    case stopped // = 1

    init() {
      self = .started
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .started
      case 1: self = .stopped
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .started: return 0
      case .stopped: return 1
      }
    }

  }

  init() {}

  fileprivate var _timestamp: UInt64? = nil
  fileprivate var _action: SessionProtos_TypingMessage.Action? = nil
}

#if swift(>=4.2)

extension SessionProtos_TypingMessage.Action: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct SessionProtos_Content {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var dataMessage: SessionProtos_DataMessage {
    get {return _dataMessage ?? SessionProtos_DataMessage()}
    set {_dataMessage = newValue}
  }
  /// Returns true if `dataMessage` has been explicitly set.
  var hasDataMessage: Bool {return self._dataMessage != nil}
  /// Clears the value of `dataMessage`. Subsequent reads from it will return its default value.
  mutating func clearDataMessage() {self._dataMessage = nil}

  var receiptMessage: SessionProtos_ReceiptMessage {
    get {return _receiptMessage ?? SessionProtos_ReceiptMessage()}
    set {_receiptMessage = newValue}
  }
  /// Returns true if `receiptMessage` has been explicitly set.
  var hasReceiptMessage: Bool {return self._receiptMessage != nil}
  /// Clears the value of `receiptMessage`. Subsequent reads from it will return its default value.
  mutating func clearReceiptMessage() {self._receiptMessage = nil}

  var typingMessage: SessionProtos_TypingMessage {
    get {return _typingMessage ?? SessionProtos_TypingMessage()}
    set {_typingMessage = newValue}
  }
  /// Returns true if `typingMessage` has been explicitly set.
  var hasTypingMessage: Bool {return self._typingMessage != nil}
  /// Clears the value of `typingMessage`. Subsequent reads from it will return its default value.
  mutating func clearTypingMessage() {self._typingMessage = nil}

  var configurationMessage: SessionProtos_ConfigurationMessage {
    get {return _configurationMessage ?? SessionProtos_ConfigurationMessage()}
    set {_configurationMessage = newValue}
  }
  /// Returns true if `configurationMessage` has been explicitly set.
  var hasConfigurationMessage: Bool {return self._configurationMessage != nil}
  /// Clears the value of `configurationMessage`. Subsequent reads from it will return its default value.
  mutating func clearConfigurationMessage() {self._configurationMessage = nil}

  var dataExtractionNotification: SessionProtos_DataExtractionNotification {
    get {return _dataExtractionNotification ?? SessionProtos_DataExtractionNotification()}
    set {_dataExtractionNotification = newValue}
  }
  /// Returns true if `dataExtractionNotification` has been explicitly set.
  var hasDataExtractionNotification: Bool {return self._dataExtractionNotification != nil}
  /// Clears the value of `dataExtractionNotification`. Subsequent reads from it will return its default value.
  mutating func clearDataExtractionNotification() {self._dataExtractionNotification = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _dataMessage: SessionProtos_DataMessage? = nil
  fileprivate var _receiptMessage: SessionProtos_ReceiptMessage? = nil
  fileprivate var _typingMessage: SessionProtos_TypingMessage? = nil
  fileprivate var _configurationMessage: SessionProtos_ConfigurationMessage? = nil
  fileprivate var _dataExtractionNotification: SessionProtos_DataExtractionNotification? = nil
}

struct SessionProtos_CallMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var offer: SessionProtos_CallMessage.Offer {
    get {return _storage._offer ?? SessionProtos_CallMessage.Offer()}
    set {_uniqueStorage()._offer = newValue}
  }
  /// Returns true if `offer` has been explicitly set.
  var hasOffer: Bool {return _storage._offer != nil}
  /// Clears the value of `offer`. Subsequent reads from it will return its default value.
  mutating func clearOffer() {_uniqueStorage()._offer = nil}

  var answer: SessionProtos_CallMessage.Answer {
    get {return _storage._answer ?? SessionProtos_CallMessage.Answer()}
    set {_uniqueStorage()._answer = newValue}
  }
  /// Returns true if `answer` has been explicitly set.
  var hasAnswer: Bool {return _storage._answer != nil}
  /// Clears the value of `answer`. Subsequent reads from it will return its default value.
  mutating func clearAnswer() {_uniqueStorage()._answer = nil}

  var iceUpdate: [SessionProtos_CallMessage.IceUpdate] {
    get {return _storage._iceUpdate}
    set {_uniqueStorage()._iceUpdate = newValue}
  }

  var legacyHangup: SessionProtos_CallMessage.Hangup {
    get {return _storage._legacyHangup ?? SessionProtos_CallMessage.Hangup()}
    set {_uniqueStorage()._legacyHangup = newValue}
  }
  /// Returns true if `legacyHangup` has been explicitly set.
  var hasLegacyHangup: Bool {return _storage._legacyHangup != nil}
  /// Clears the value of `legacyHangup`. Subsequent reads from it will return its default value.
  mutating func clearLegacyHangup() {_uniqueStorage()._legacyHangup = nil}

  var busy: SessionProtos_CallMessage.Busy {
    get {return _storage._busy ?? SessionProtos_CallMessage.Busy()}
    set {_uniqueStorage()._busy = newValue}
  }
  /// Returns true if `busy` has been explicitly set.
  var hasBusy: Bool {return _storage._busy != nil}
  /// Clears the value of `busy`. Subsequent reads from it will return its default value.
  mutating func clearBusy() {_uniqueStorage()._busy = nil}

  /// Signal-iOS sends profile key with call messages
  /// for earlier discovery.
  var profileKey: Data {
    get {return _storage._profileKey ?? Data()}
    set {_uniqueStorage()._profileKey = newValue}
  }
  /// Returns true if `profileKey` has been explicitly set.
  var hasProfileKey: Bool {return _storage._profileKey != nil}
  /// Clears the value of `profileKey`. Subsequent reads from it will return its default value.
  mutating func clearProfileKey() {_uniqueStorage()._profileKey = nil}

  var hangup: SessionProtos_CallMessage.Hangup {
    get {return _storage._hangup ?? SessionProtos_CallMessage.Hangup()}
    set {_uniqueStorage()._hangup = newValue}
  }
  /// Returns true if `hangup` has been explicitly set.
  var hasHangup: Bool {return _storage._hangup != nil}
  /// Clears the value of `hangup`. Subsequent reads from it will return its default value.
  mutating func clearHangup() {_uniqueStorage()._hangup = nil}

  var supportsMultiRing: Bool {
    get {return _storage._supportsMultiRing ?? false}
    set {_uniqueStorage()._supportsMultiRing = newValue}
  }
  /// Returns true if `supportsMultiRing` has been explicitly set.
  var hasSupportsMultiRing: Bool {return _storage._supportsMultiRing != nil}
  /// Clears the value of `supportsMultiRing`. Subsequent reads from it will return its default value.
  mutating func clearSupportsMultiRing() {_uniqueStorage()._supportsMultiRing = nil}

  var destinationDeviceID: UInt32 {
    get {return _storage._destinationDeviceID ?? 0}
    set {_uniqueStorage()._destinationDeviceID = newValue}
  }
  /// Returns true if `destinationDeviceID` has been explicitly set.
  var hasDestinationDeviceID: Bool {return _storage._destinationDeviceID != nil}
  /// Clears the value of `destinationDeviceID`. Subsequent reads from it will return its default value.
  mutating func clearDestinationDeviceID() {_uniqueStorage()._destinationDeviceID = nil}

  var opaque: SessionProtos_CallMessage.Opaque {
    get {return _storage._opaque ?? SessionProtos_CallMessage.Opaque()}
    set {_uniqueStorage()._opaque = newValue}
  }
  /// Returns true if `opaque` has been explicitly set.
  var hasOpaque: Bool {return _storage._opaque != nil}
  /// Clears the value of `opaque`. Subsequent reads from it will return its default value.
  mutating func clearOpaque() {_uniqueStorage()._opaque = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Offer {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// @required
    var id: UInt64 {
      get {return _id ?? 0}
      set {_id = newValue}
    }
    /// Returns true if `id` has been explicitly set.
    var hasID: Bool {return self._id != nil}
    /// Clears the value of `id`. Subsequent reads from it will return its default value.
    mutating func clearID() {self._id = nil}

    /// Legacy/deprecated; replaced by 'opaque'
    var sdp: String {
      get {return _sdp ?? String()}
      set {_sdp = newValue}
    }
    /// Returns true if `sdp` has been explicitly set.
    var hasSdp: Bool {return self._sdp != nil}
    /// Clears the value of `sdp`. Subsequent reads from it will return its default value.
    mutating func clearSdp() {self._sdp = nil}

    var type: SessionProtos_CallMessage.Offer.TypeEnum {
      get {return _type ?? .offerAudioCall}
      set {_type = newValue}
    }
    /// Returns true if `type` has been explicitly set.
    var hasType: Bool {return self._type != nil}
    /// Clears the value of `type`. Subsequent reads from it will return its default value.
    mutating func clearType() {self._type = nil}

    var opaque: Data {
      get {return _opaque ?? Data()}
      set {_opaque = newValue}
    }
    /// Returns true if `opaque` has been explicitly set.
    var hasOpaque: Bool {return self._opaque != nil}
    /// Clears the value of `opaque`. Subsequent reads from it will return its default value.
    mutating func clearOpaque() {self._opaque = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum TypeEnum: SwiftProtobuf.Enum {
      typealias RawValue = Int
      case offerAudioCall // = 0

      /// next index 3, skip 2 – it was the unused "NEED_PERMISSION" type
      case offerVideoCall // = 1

      init() {
        self = .offerAudioCall
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .offerAudioCall
        case 1: self = .offerVideoCall
        default: return nil
        }
      }

      var rawValue: Int {
        switch self {
        case .offerAudioCall: return 0
        case .offerVideoCall: return 1
        }
      }

    }

    init() {}

    fileprivate var _id: UInt64? = nil
    fileprivate var _sdp: String? = nil
    fileprivate var _type: SessionProtos_CallMessage.Offer.TypeEnum? = nil
    fileprivate var _opaque: Data? = nil
  }

  struct Answer {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// @required
    var id: UInt64 {
      get {return _id ?? 0}
      set {_id = newValue}
    }
    /// Returns true if `id` has been explicitly set.
    var hasID: Bool {return self._id != nil}
    /// Clears the value of `id`. Subsequent reads from it will return its default value.
    mutating func clearID() {self._id = nil}

    /// Legacy/deprecated; replaced by 'opaque'
    var sdp: String {
      get {return _sdp ?? String()}
      set {_sdp = newValue}
    }
    /// Returns true if `sdp` has been explicitly set.
    var hasSdp: Bool {return self._sdp != nil}
    /// Clears the value of `sdp`. Subsequent reads from it will return its default value.
    mutating func clearSdp() {self._sdp = nil}

    var opaque: Data {
      get {return _opaque ?? Data()}
      set {_opaque = newValue}
    }
    /// Returns true if `opaque` has been explicitly set.
    var hasOpaque: Bool {return self._opaque != nil}
    /// Clears the value of `opaque`. Subsequent reads from it will return its default value.
    mutating func clearOpaque() {self._opaque = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _id: UInt64? = nil
    fileprivate var _sdp: String? = nil
    fileprivate var _opaque: Data? = nil
  }

  struct IceUpdate {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// @required
    var id: UInt64 {
      get {return _id ?? 0}
      set {_id = newValue}
    }
    /// Returns true if `id` has been explicitly set.
    var hasID: Bool {return self._id != nil}
    /// Clears the value of `id`. Subsequent reads from it will return its default value.
    mutating func clearID() {self._id = nil}

    /// Legacy/deprecated; remove when old clients are gone.
    var mid: String {
      get {return _mid ?? String()}
      set {_mid = newValue}
    }
    /// Returns true if `mid` has been explicitly set.
    var hasMid: Bool {return self._mid != nil}
    /// Clears the value of `mid`. Subsequent reads from it will return its default value.
    mutating func clearMid() {self._mid = nil}

    /// Legacy/deprecated; remove when old clients are gone.
    var line: UInt32 {
      get {return _line ?? 0}
      set {_line = newValue}
    }
    /// Returns true if `line` has been explicitly set.
    var hasLine: Bool {return self._line != nil}
    /// Clears the value of `line`. Subsequent reads from it will return its default value.
    mutating func clearLine() {self._line = nil}

    /// Legacy/deprecated; replaced by 'opaque'
    var sdp: String {
      get {return _sdp ?? String()}
      set {_sdp = newValue}
    }
    /// Returns true if `sdp` has been explicitly set.
    var hasSdp: Bool {return self._sdp != nil}
    /// Clears the value of `sdp`. Subsequent reads from it will return its default value.
    mutating func clearSdp() {self._sdp = nil}

    var opaque: Data {
      get {return _opaque ?? Data()}
      set {_opaque = newValue}
    }
    /// Returns true if `opaque` has been explicitly set.
    var hasOpaque: Bool {return self._opaque != nil}
    /// Clears the value of `opaque`. Subsequent reads from it will return its default value.
    mutating func clearOpaque() {self._opaque = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _id: UInt64? = nil
    fileprivate var _mid: String? = nil
    fileprivate var _line: UInt32? = nil
    fileprivate var _sdp: String? = nil
    fileprivate var _opaque: Data? = nil
  }

  struct Busy {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// @required
    var id: UInt64 {
      get {return _id ?? 0}
      set {_id = newValue}
    }
    /// Returns true if `id` has been explicitly set.
    var hasID: Bool {return self._id != nil}
    /// Clears the value of `id`. Subsequent reads from it will return its default value.
    mutating func clearID() {self._id = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _id: UInt64? = nil
  }

  struct Hangup {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// @required
    var id: UInt64 {
      get {return _id ?? 0}
      set {_id = newValue}
    }
    /// Returns true if `id` has been explicitly set.
    var hasID: Bool {return self._id != nil}
    /// Clears the value of `id`. Subsequent reads from it will return its default value.
    mutating func clearID() {self._id = nil}

    var type: SessionProtos_CallMessage.Hangup.TypeEnum {
      get {return _type ?? .hangupNormal}
      set {_type = newValue}
    }
    /// Returns true if `type` has been explicitly set.
    var hasType: Bool {return self._type != nil}
    /// Clears the value of `type`. Subsequent reads from it will return its default value.
    mutating func clearType() {self._type = nil}

    var deviceID: UInt32 {
      get {return _deviceID ?? 0}
      set {_deviceID = newValue}
    }
    /// Returns true if `deviceID` has been explicitly set.
    var hasDeviceID: Bool {return self._deviceID != nil}
    /// Clears the value of `deviceID`. Subsequent reads from it will return its default value.
    mutating func clearDeviceID() {self._deviceID = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum TypeEnum: SwiftProtobuf.Enum {
      typealias RawValue = Int
      case hangupNormal // = 0
      case hangupAccepted // = 1
      case hangupDeclined // = 2
      case hangupBusy // = 3
      case hangupNeedPermission // = 4

      init() {
        self = .hangupNormal
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 0: self = .hangupNormal
        case 1: self = .hangupAccepted
        case 2: self = .hangupDeclined
        case 3: self = .hangupBusy
        case 4: self = .hangupNeedPermission
        default: return nil
        }
      }

      var rawValue: Int {
        switch self {
        case .hangupNormal: return 0
        case .hangupAccepted: return 1
        case .hangupDeclined: return 2
        case .hangupBusy: return 3
        case .hangupNeedPermission: return 4
        }
      }

    }

    init() {}

    fileprivate var _id: UInt64? = nil
    fileprivate var _type: SessionProtos_CallMessage.Hangup.TypeEnum? = nil
    fileprivate var _deviceID: UInt32? = nil
  }

  struct Opaque {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var data: Data {
      get {return _data ?? Data()}
      set {_data = newValue}
    }
    /// Returns true if `data` has been explicitly set.
    var hasData: Bool {return self._data != nil}
    /// Clears the value of `data`. Subsequent reads from it will return its default value.
    mutating func clearData() {self._data = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _data: Data? = nil
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension SessionProtos_CallMessage.Offer.TypeEnum: CaseIterable {
  // Support synthesized by the compiler.
}

extension SessionProtos_CallMessage.Hangup.TypeEnum: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct SessionProtos_KeyPair {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var publicKey: Data {
    get {return _publicKey ?? Data()}
    set {_publicKey = newValue}
  }
  /// Returns true if `publicKey` has been explicitly set.
  var hasPublicKey: Bool {return self._publicKey != nil}
  /// Clears the value of `publicKey`. Subsequent reads from it will return its default value.
  mutating func clearPublicKey() {self._publicKey = nil}

  /// @required
  var privateKey: Data {
    get {return _privateKey ?? Data()}
    set {_privateKey = newValue}
  }
  /// Returns true if `privateKey` has been explicitly set.
  var hasPrivateKey: Bool {return self._privateKey != nil}
  /// Clears the value of `privateKey`. Subsequent reads from it will return its default value.
  mutating func clearPrivateKey() {self._privateKey = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _publicKey: Data? = nil
  fileprivate var _privateKey: Data? = nil
}

struct SessionProtos_DataExtractionNotification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var type: SessionProtos_DataExtractionNotification.TypeEnum {
    get {return _type ?? .screenshot}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  var timestamp: UInt64 {
    get {return _timestamp ?? 0}
    set {_timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return self._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {self._timestamp = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum TypeEnum: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case screenshot // = 1

    /// timestamp
    case mediaSaved // = 2

    init() {
      self = .screenshot
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 1: self = .screenshot
      case 2: self = .mediaSaved
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .screenshot: return 1
      case .mediaSaved: return 2
      }
    }

  }

  init() {}

  fileprivate var _type: SessionProtos_DataExtractionNotification.TypeEnum? = nil
  fileprivate var _timestamp: UInt64? = nil
}

#if swift(>=4.2)

extension SessionProtos_DataExtractionNotification.TypeEnum: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct SessionProtos_DataMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var body: String {
    get {return _storage._body ?? String()}
    set {_uniqueStorage()._body = newValue}
  }
  /// Returns true if `body` has been explicitly set.
  var hasBody: Bool {return _storage._body != nil}
  /// Clears the value of `body`. Subsequent reads from it will return its default value.
  mutating func clearBody() {_uniqueStorage()._body = nil}

  var attachments: [SessionProtos_AttachmentPointer] {
    get {return _storage._attachments}
    set {_uniqueStorage()._attachments = newValue}
  }

  var group: SessionProtos_GroupContext {
    get {return _storage._group ?? SessionProtos_GroupContext()}
    set {_uniqueStorage()._group = newValue}
  }
  /// Returns true if `group` has been explicitly set.
  var hasGroup: Bool {return _storage._group != nil}
  /// Clears the value of `group`. Subsequent reads from it will return its default value.
  mutating func clearGroup() {_uniqueStorage()._group = nil}

  var flags: UInt32 {
    get {return _storage._flags ?? 0}
    set {_uniqueStorage()._flags = newValue}
  }
  /// Returns true if `flags` has been explicitly set.
  var hasFlags: Bool {return _storage._flags != nil}
  /// Clears the value of `flags`. Subsequent reads from it will return its default value.
  mutating func clearFlags() {_uniqueStorage()._flags = nil}

  var expireTimer: UInt32 {
    get {return _storage._expireTimer ?? 0}
    set {_uniqueStorage()._expireTimer = newValue}
  }
  /// Returns true if `expireTimer` has been explicitly set.
  var hasExpireTimer: Bool {return _storage._expireTimer != nil}
  /// Clears the value of `expireTimer`. Subsequent reads from it will return its default value.
  mutating func clearExpireTimer() {_uniqueStorage()._expireTimer = nil}

  var profileKey: Data {
    get {return _storage._profileKey ?? Data()}
    set {_uniqueStorage()._profileKey = newValue}
  }
  /// Returns true if `profileKey` has been explicitly set.
  var hasProfileKey: Bool {return _storage._profileKey != nil}
  /// Clears the value of `profileKey`. Subsequent reads from it will return its default value.
  mutating func clearProfileKey() {_uniqueStorage()._profileKey = nil}

  var timestamp: UInt64 {
    get {return _storage._timestamp ?? 0}
    set {_uniqueStorage()._timestamp = newValue}
  }
  /// Returns true if `timestamp` has been explicitly set.
  var hasTimestamp: Bool {return _storage._timestamp != nil}
  /// Clears the value of `timestamp`. Subsequent reads from it will return its default value.
  mutating func clearTimestamp() {_uniqueStorage()._timestamp = nil}

  var quote: SessionProtos_DataMessage.Quote {
    get {return _storage._quote ?? SessionProtos_DataMessage.Quote()}
    set {_uniqueStorage()._quote = newValue}
  }
  /// Returns true if `quote` has been explicitly set.
  var hasQuote: Bool {return _storage._quote != nil}
  /// Clears the value of `quote`. Subsequent reads from it will return its default value.
  mutating func clearQuote() {_uniqueStorage()._quote = nil}

  var preview: [SessionProtos_DataMessage.Preview] {
    get {return _storage._preview}
    set {_uniqueStorage()._preview = newValue}
  }

  var groupCallUpdate: SessionProtos_DataMessage.GroupCallUpdate {
    get {return _storage._groupCallUpdate ?? SessionProtos_DataMessage.GroupCallUpdate()}
    set {_uniqueStorage()._groupCallUpdate = newValue}
  }
  /// Returns true if `groupCallUpdate` has been explicitly set.
  var hasGroupCallUpdate: Bool {return _storage._groupCallUpdate != nil}
  /// Clears the value of `groupCallUpdate`. Subsequent reads from it will return its default value.
  mutating func clearGroupCallUpdate() {_uniqueStorage()._groupCallUpdate = nil}

  var profile: SessionProtos_DataMessage.LokiProfile {
    get {return _storage._profile ?? SessionProtos_DataMessage.LokiProfile()}
    set {_uniqueStorage()._profile = newValue}
  }
  /// Returns true if `profile` has been explicitly set.
  var hasProfile: Bool {return _storage._profile != nil}
  /// Clears the value of `profile`. Subsequent reads from it will return its default value.
  mutating func clearProfile() {_uniqueStorage()._profile = nil}

  var openGroupInvitation: SessionProtos_DataMessage.OpenGroupInvitation {
    get {return _storage._openGroupInvitation ?? SessionProtos_DataMessage.OpenGroupInvitation()}
    set {_uniqueStorage()._openGroupInvitation = newValue}
  }
  /// Returns true if `openGroupInvitation` has been explicitly set.
  var hasOpenGroupInvitation: Bool {return _storage._openGroupInvitation != nil}
  /// Clears the value of `openGroupInvitation`. Subsequent reads from it will return its default value.
  mutating func clearOpenGroupInvitation() {_uniqueStorage()._openGroupInvitation = nil}

  var closedGroupControlMessage: SessionProtos_DataMessage.ClosedGroupControlMessage {
    get {return _storage._closedGroupControlMessage ?? SessionProtos_DataMessage.ClosedGroupControlMessage()}
    set {_uniqueStorage()._closedGroupControlMessage = newValue}
  }
  /// Returns true if `closedGroupControlMessage` has been explicitly set.
  var hasClosedGroupControlMessage: Bool {return _storage._closedGroupControlMessage != nil}
  /// Clears the value of `closedGroupControlMessage`. Subsequent reads from it will return its default value.
  mutating func clearClosedGroupControlMessage() {_uniqueStorage()._closedGroupControlMessage = nil}

  var syncTarget: String {
    get {return _storage._syncTarget ?? String()}
    set {_uniqueStorage()._syncTarget = newValue}
  }
  /// Returns true if `syncTarget` has been explicitly set.
  var hasSyncTarget: Bool {return _storage._syncTarget != nil}
  /// Clears the value of `syncTarget`. Subsequent reads from it will return its default value.
  mutating func clearSyncTarget() {_uniqueStorage()._syncTarget = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Flags: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case expirationTimerUpdate // = 2

    init() {
      self = .expirationTimerUpdate
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 2: self = .expirationTimerUpdate
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .expirationTimerUpdate: return 2
      }
    }

  }

  struct Quote {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// @required
    var id: UInt64 {
      get {return _id ?? 0}
      set {_id = newValue}
    }
    /// Returns true if `id` has been explicitly set.
    var hasID: Bool {return self._id != nil}
    /// Clears the value of `id`. Subsequent reads from it will return its default value.
    mutating func clearID() {self._id = nil}

    /// @required
    var author: String {
      get {return _author ?? String()}
      set {_author = newValue}
    }
    /// Returns true if `author` has been explicitly set.
    var hasAuthor: Bool {return self._author != nil}
    /// Clears the value of `author`. Subsequent reads from it will return its default value.
    mutating func clearAuthor() {self._author = nil}

    var text: String {
      get {return _text ?? String()}
      set {_text = newValue}
    }
    /// Returns true if `text` has been explicitly set.
    var hasText: Bool {return self._text != nil}
    /// Clears the value of `text`. Subsequent reads from it will return its default value.
    mutating func clearText() {self._text = nil}

    var attachments: [SessionProtos_DataMessage.Quote.QuotedAttachment] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct QuotedAttachment {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var contentType: String {
        get {return _contentType ?? String()}
        set {_contentType = newValue}
      }
      /// Returns true if `contentType` has been explicitly set.
      var hasContentType: Bool {return self._contentType != nil}
      /// Clears the value of `contentType`. Subsequent reads from it will return its default value.
      mutating func clearContentType() {self._contentType = nil}

      var fileName: String {
        get {return _fileName ?? String()}
        set {_fileName = newValue}
      }
      /// Returns true if `fileName` has been explicitly set.
      var hasFileName: Bool {return self._fileName != nil}
      /// Clears the value of `fileName`. Subsequent reads from it will return its default value.
      mutating func clearFileName() {self._fileName = nil}

      var thumbnail: SessionProtos_AttachmentPointer {
        get {return _thumbnail ?? SessionProtos_AttachmentPointer()}
        set {_thumbnail = newValue}
      }
      /// Returns true if `thumbnail` has been explicitly set.
      var hasThumbnail: Bool {return self._thumbnail != nil}
      /// Clears the value of `thumbnail`. Subsequent reads from it will return its default value.
      mutating func clearThumbnail() {self._thumbnail = nil}

      var flags: UInt32 {
        get {return _flags ?? 0}
        set {_flags = newValue}
      }
      /// Returns true if `flags` has been explicitly set.
      var hasFlags: Bool {return self._flags != nil}
      /// Clears the value of `flags`. Subsequent reads from it will return its default value.
      mutating func clearFlags() {self._flags = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      enum Flags: SwiftProtobuf.Enum {
        typealias RawValue = Int
        case voiceMessage // = 1

        init() {
          self = .voiceMessage
        }

        init?(rawValue: Int) {
          switch rawValue {
          case 1: self = .voiceMessage
          default: return nil
          }
        }

        var rawValue: Int {
          switch self {
          case .voiceMessage: return 1
          }
        }

      }

      init() {}

      fileprivate var _contentType: String? = nil
      fileprivate var _fileName: String? = nil
      fileprivate var _thumbnail: SessionProtos_AttachmentPointer? = nil
      fileprivate var _flags: UInt32? = nil
    }

    init() {}

    fileprivate var _id: UInt64? = nil
    fileprivate var _author: String? = nil
    fileprivate var _text: String? = nil
  }

  struct Preview {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// @required
    var url: String {
      get {return _url ?? String()}
      set {_url = newValue}
    }
    /// Returns true if `url` has been explicitly set.
    var hasURL: Bool {return self._url != nil}
    /// Clears the value of `url`. Subsequent reads from it will return its default value.
    mutating func clearURL() {self._url = nil}

    var title: String {
      get {return _title ?? String()}
      set {_title = newValue}
    }
    /// Returns true if `title` has been explicitly set.
    var hasTitle: Bool {return self._title != nil}
    /// Clears the value of `title`. Subsequent reads from it will return its default value.
    mutating func clearTitle() {self._title = nil}

    var image: SessionProtos_AttachmentPointer {
      get {return _image ?? SessionProtos_AttachmentPointer()}
      set {_image = newValue}
    }
    /// Returns true if `image` has been explicitly set.
    var hasImage: Bool {return self._image != nil}
    /// Clears the value of `image`. Subsequent reads from it will return its default value.
    mutating func clearImage() {self._image = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _url: String? = nil
    fileprivate var _title: String? = nil
    fileprivate var _image: SessionProtos_AttachmentPointer? = nil
  }

  struct LokiProfile {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var displayName: String {
      get {return _displayName ?? String()}
      set {_displayName = newValue}
    }
    /// Returns true if `displayName` has been explicitly set.
    var hasDisplayName: Bool {return self._displayName != nil}
    /// Clears the value of `displayName`. Subsequent reads from it will return its default value.
    mutating func clearDisplayName() {self._displayName = nil}

    var profilePicture: String {
      get {return _profilePicture ?? String()}
      set {_profilePicture = newValue}
    }
    /// Returns true if `profilePicture` has been explicitly set.
    var hasProfilePicture: Bool {return self._profilePicture != nil}
    /// Clears the value of `profilePicture`. Subsequent reads from it will return its default value.
    mutating func clearProfilePicture() {self._profilePicture = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _displayName: String? = nil
    fileprivate var _profilePicture: String? = nil
  }

  struct OpenGroupInvitation {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// @required
    var url: String {
      get {return _url ?? String()}
      set {_url = newValue}
    }
    /// Returns true if `url` has been explicitly set.
    var hasURL: Bool {return self._url != nil}
    /// Clears the value of `url`. Subsequent reads from it will return its default value.
    mutating func clearURL() {self._url = nil}

    /// @required
    var name: String {
      get {return _name ?? String()}
      set {_name = newValue}
    }
    /// Returns true if `name` has been explicitly set.
    var hasName: Bool {return self._name != nil}
    /// Clears the value of `name`. Subsequent reads from it will return its default value.
    mutating func clearName() {self._name = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _url: String? = nil
    fileprivate var _name: String? = nil
  }

  struct ClosedGroupControlMessage {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// @required
    var type: SessionProtos_DataMessage.ClosedGroupControlMessage.TypeEnum {
      get {return _type ?? .new}
      set {_type = newValue}
    }
    /// Returns true if `type` has been explicitly set.
    var hasType: Bool {return self._type != nil}
    /// Clears the value of `type`. Subsequent reads from it will return its default value.
    mutating func clearType() {self._type = nil}

    var publicKey: Data {
      get {return _publicKey ?? Data()}
      set {_publicKey = newValue}
    }
    /// Returns true if `publicKey` has been explicitly set.
    var hasPublicKey: Bool {return self._publicKey != nil}
    /// Clears the value of `publicKey`. Subsequent reads from it will return its default value.
    mutating func clearPublicKey() {self._publicKey = nil}

    var name: String {
      get {return _name ?? String()}
      set {_name = newValue}
    }
    /// Returns true if `name` has been explicitly set.
    var hasName: Bool {return self._name != nil}
    /// Clears the value of `name`. Subsequent reads from it will return its default value.
    mutating func clearName() {self._name = nil}

    var encryptionKeyPair: SessionProtos_KeyPair {
      get {return _encryptionKeyPair ?? SessionProtos_KeyPair()}
      set {_encryptionKeyPair = newValue}
    }
    /// Returns true if `encryptionKeyPair` has been explicitly set.
    var hasEncryptionKeyPair: Bool {return self._encryptionKeyPair != nil}
    /// Clears the value of `encryptionKeyPair`. Subsequent reads from it will return its default value.
    mutating func clearEncryptionKeyPair() {self._encryptionKeyPair = nil}

    var members: [Data] = []

    var admins: [Data] = []

    var wrappers: [SessionProtos_DataMessage.ClosedGroupControlMessage.KeyPairWrapper] = []

    var expirationTimer: UInt32 {
      get {return _expirationTimer ?? 0}
      set {_expirationTimer = newValue}
    }
    /// Returns true if `expirationTimer` has been explicitly set.
    var hasExpirationTimer: Bool {return self._expirationTimer != nil}
    /// Clears the value of `expirationTimer`. Subsequent reads from it will return its default value.
    mutating func clearExpirationTimer() {self._expirationTimer = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum TypeEnum: SwiftProtobuf.Enum {
      typealias RawValue = Int

      /// publicKey, name, encryptionKeyPair, members, admins, expirationTimer
      case new // = 1

      /// publicKey, wrappers
      case encryptionKeyPair // = 3

      /// name
      case nameChange // = 4

      /// members
      case membersAdded // = 5

      /// members
      case membersRemoved // = 6
      case memberLeft // = 7
      case encryptionKeyPairRequest // = 8

      init() {
        self = .new
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 1: self = .new
        case 3: self = .encryptionKeyPair
        case 4: self = .nameChange
        case 5: self = .membersAdded
        case 6: self = .membersRemoved
        case 7: self = .memberLeft
        case 8: self = .encryptionKeyPairRequest
        default: return nil
        }
      }

      var rawValue: Int {
        switch self {
        case .new: return 1
        case .encryptionKeyPair: return 3
        case .nameChange: return 4
        case .membersAdded: return 5
        case .membersRemoved: return 6
        case .memberLeft: return 7
        case .encryptionKeyPairRequest: return 8
        }
      }

    }

    struct KeyPairWrapper {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// @required
      var publicKey: Data {
        get {return _publicKey ?? Data()}
        set {_publicKey = newValue}
      }
      /// Returns true if `publicKey` has been explicitly set.
      var hasPublicKey: Bool {return self._publicKey != nil}
      /// Clears the value of `publicKey`. Subsequent reads from it will return its default value.
      mutating func clearPublicKey() {self._publicKey = nil}

      /// @required
      var encryptedKeyPair: Data {
        get {return _encryptedKeyPair ?? Data()}
        set {_encryptedKeyPair = newValue}
      }
      /// Returns true if `encryptedKeyPair` has been explicitly set.
      var hasEncryptedKeyPair: Bool {return self._encryptedKeyPair != nil}
      /// Clears the value of `encryptedKeyPair`. Subsequent reads from it will return its default value.
      mutating func clearEncryptedKeyPair() {self._encryptedKeyPair = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _publicKey: Data? = nil
      fileprivate var _encryptedKeyPair: Data? = nil
    }

    init() {}

    fileprivate var _type: SessionProtos_DataMessage.ClosedGroupControlMessage.TypeEnum? = nil
    fileprivate var _publicKey: Data? = nil
    fileprivate var _name: String? = nil
    fileprivate var _encryptionKeyPair: SessionProtos_KeyPair? = nil
    fileprivate var _expirationTimer: UInt32? = nil
  }

  struct GroupCallUpdate {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var eraID: String {
      get {return _eraID ?? String()}
      set {_eraID = newValue}
    }
    /// Returns true if `eraID` has been explicitly set.
    var hasEraID: Bool {return self._eraID != nil}
    /// Clears the value of `eraID`. Subsequent reads from it will return its default value.
    mutating func clearEraID() {self._eraID = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _eraID: String? = nil
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension SessionProtos_DataMessage.Flags: CaseIterable {
  // Support synthesized by the compiler.
}

extension SessionProtos_DataMessage.Quote.QuotedAttachment.Flags: CaseIterable {
  // Support synthesized by the compiler.
}

extension SessionProtos_DataMessage.ClosedGroupControlMessage.TypeEnum: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct SessionProtos_ConfigurationMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var closedGroups: [SessionProtos_ConfigurationMessage.ClosedGroup] = []

  var openGroups: [String] = []

  var displayName: String {
    get {return _displayName ?? String()}
    set {_displayName = newValue}
  }
  /// Returns true if `displayName` has been explicitly set.
  var hasDisplayName: Bool {return self._displayName != nil}
  /// Clears the value of `displayName`. Subsequent reads from it will return its default value.
  mutating func clearDisplayName() {self._displayName = nil}

  var profilePicture: String {
    get {return _profilePicture ?? String()}
    set {_profilePicture = newValue}
  }
  /// Returns true if `profilePicture` has been explicitly set.
  var hasProfilePicture: Bool {return self._profilePicture != nil}
  /// Clears the value of `profilePicture`. Subsequent reads from it will return its default value.
  mutating func clearProfilePicture() {self._profilePicture = nil}

  var profileKey: Data {
    get {return _profileKey ?? Data()}
    set {_profileKey = newValue}
  }
  /// Returns true if `profileKey` has been explicitly set.
  var hasProfileKey: Bool {return self._profileKey != nil}
  /// Clears the value of `profileKey`. Subsequent reads from it will return its default value.
  mutating func clearProfileKey() {self._profileKey = nil}

  var contacts: [SessionProtos_ConfigurationMessage.Contact] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct ClosedGroup {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var publicKey: Data {
      get {return _publicKey ?? Data()}
      set {_publicKey = newValue}
    }
    /// Returns true if `publicKey` has been explicitly set.
    var hasPublicKey: Bool {return self._publicKey != nil}
    /// Clears the value of `publicKey`. Subsequent reads from it will return its default value.
    mutating func clearPublicKey() {self._publicKey = nil}

    var name: String {
      get {return _name ?? String()}
      set {_name = newValue}
    }
    /// Returns true if `name` has been explicitly set.
    var hasName: Bool {return self._name != nil}
    /// Clears the value of `name`. Subsequent reads from it will return its default value.
    mutating func clearName() {self._name = nil}

    var encryptionKeyPair: SessionProtos_KeyPair {
      get {return _encryptionKeyPair ?? SessionProtos_KeyPair()}
      set {_encryptionKeyPair = newValue}
    }
    /// Returns true if `encryptionKeyPair` has been explicitly set.
    var hasEncryptionKeyPair: Bool {return self._encryptionKeyPair != nil}
    /// Clears the value of `encryptionKeyPair`. Subsequent reads from it will return its default value.
    mutating func clearEncryptionKeyPair() {self._encryptionKeyPair = nil}

    var members: [Data] = []

    var admins: [Data] = []

    var expirationTimer: UInt32 {
      get {return _expirationTimer ?? 0}
      set {_expirationTimer = newValue}
    }
    /// Returns true if `expirationTimer` has been explicitly set.
    var hasExpirationTimer: Bool {return self._expirationTimer != nil}
    /// Clears the value of `expirationTimer`. Subsequent reads from it will return its default value.
    mutating func clearExpirationTimer() {self._expirationTimer = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _publicKey: Data? = nil
    fileprivate var _name: String? = nil
    fileprivate var _encryptionKeyPair: SessionProtos_KeyPair? = nil
    fileprivate var _expirationTimer: UInt32? = nil
  }

  struct Contact {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// @required
    var publicKey: Data {
      get {return _publicKey ?? Data()}
      set {_publicKey = newValue}
    }
    /// Returns true if `publicKey` has been explicitly set.
    var hasPublicKey: Bool {return self._publicKey != nil}
    /// Clears the value of `publicKey`. Subsequent reads from it will return its default value.
    mutating func clearPublicKey() {self._publicKey = nil}

    /// @required
    var name: String {
      get {return _name ?? String()}
      set {_name = newValue}
    }
    /// Returns true if `name` has been explicitly set.
    var hasName: Bool {return self._name != nil}
    /// Clears the value of `name`. Subsequent reads from it will return its default value.
    mutating func clearName() {self._name = nil}

    var profilePicture: String {
      get {return _profilePicture ?? String()}
      set {_profilePicture = newValue}
    }
    /// Returns true if `profilePicture` has been explicitly set.
    var hasProfilePicture: Bool {return self._profilePicture != nil}
    /// Clears the value of `profilePicture`. Subsequent reads from it will return its default value.
    mutating func clearProfilePicture() {self._profilePicture = nil}

    var profileKey: Data {
      get {return _profileKey ?? Data()}
      set {_profileKey = newValue}
    }
    /// Returns true if `profileKey` has been explicitly set.
    var hasProfileKey: Bool {return self._profileKey != nil}
    /// Clears the value of `profileKey`. Subsequent reads from it will return its default value.
    mutating func clearProfileKey() {self._profileKey = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _publicKey: Data? = nil
    fileprivate var _name: String? = nil
    fileprivate var _profilePicture: String? = nil
    fileprivate var _profileKey: Data? = nil
  }

  init() {}

  fileprivate var _displayName: String? = nil
  fileprivate var _profilePicture: String? = nil
  fileprivate var _profileKey: Data? = nil
}

struct SessionProtos_ReceiptMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var type: SessionProtos_ReceiptMessage.TypeEnum {
    get {return _type ?? .delivery}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  var timestamp: [UInt64] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum TypeEnum: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case delivery // = 0
    case read // = 1

    init() {
      self = .delivery
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .delivery
      case 1: self = .read
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .delivery: return 0
      case .read: return 1
      }
    }

  }

  init() {}

  fileprivate var _type: SessionProtos_ReceiptMessage.TypeEnum? = nil
}

#if swift(>=4.2)

extension SessionProtos_ReceiptMessage.TypeEnum: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct SessionProtos_AttachmentPointer {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var id: UInt64 {
    get {return _id ?? 0}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var contentType: String {
    get {return _contentType ?? String()}
    set {_contentType = newValue}
  }
  /// Returns true if `contentType` has been explicitly set.
  var hasContentType: Bool {return self._contentType != nil}
  /// Clears the value of `contentType`. Subsequent reads from it will return its default value.
  mutating func clearContentType() {self._contentType = nil}

  var key: Data {
    get {return _key ?? Data()}
    set {_key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  var hasKey: Bool {return self._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  mutating func clearKey() {self._key = nil}

  var size: UInt32 {
    get {return _size ?? 0}
    set {_size = newValue}
  }
  /// Returns true if `size` has been explicitly set.
  var hasSize: Bool {return self._size != nil}
  /// Clears the value of `size`. Subsequent reads from it will return its default value.
  mutating func clearSize() {self._size = nil}

  var thumbnail: Data {
    get {return _thumbnail ?? Data()}
    set {_thumbnail = newValue}
  }
  /// Returns true if `thumbnail` has been explicitly set.
  var hasThumbnail: Bool {return self._thumbnail != nil}
  /// Clears the value of `thumbnail`. Subsequent reads from it will return its default value.
  mutating func clearThumbnail() {self._thumbnail = nil}

  var digest: Data {
    get {return _digest ?? Data()}
    set {_digest = newValue}
  }
  /// Returns true if `digest` has been explicitly set.
  var hasDigest: Bool {return self._digest != nil}
  /// Clears the value of `digest`. Subsequent reads from it will return its default value.
  mutating func clearDigest() {self._digest = nil}

  var fileName: String {
    get {return _fileName ?? String()}
    set {_fileName = newValue}
  }
  /// Returns true if `fileName` has been explicitly set.
  var hasFileName: Bool {return self._fileName != nil}
  /// Clears the value of `fileName`. Subsequent reads from it will return its default value.
  mutating func clearFileName() {self._fileName = nil}

  var flags: UInt32 {
    get {return _flags ?? 0}
    set {_flags = newValue}
  }
  /// Returns true if `flags` has been explicitly set.
  var hasFlags: Bool {return self._flags != nil}
  /// Clears the value of `flags`. Subsequent reads from it will return its default value.
  mutating func clearFlags() {self._flags = nil}

  var width: UInt32 {
    get {return _width ?? 0}
    set {_width = newValue}
  }
  /// Returns true if `width` has been explicitly set.
  var hasWidth: Bool {return self._width != nil}
  /// Clears the value of `width`. Subsequent reads from it will return its default value.
  mutating func clearWidth() {self._width = nil}

  var height: UInt32 {
    get {return _height ?? 0}
    set {_height = newValue}
  }
  /// Returns true if `height` has been explicitly set.
  var hasHeight: Bool {return self._height != nil}
  /// Clears the value of `height`. Subsequent reads from it will return its default value.
  mutating func clearHeight() {self._height = nil}

  var caption: String {
    get {return _caption ?? String()}
    set {_caption = newValue}
  }
  /// Returns true if `caption` has been explicitly set.
  var hasCaption: Bool {return self._caption != nil}
  /// Clears the value of `caption`. Subsequent reads from it will return its default value.
  mutating func clearCaption() {self._caption = nil}

  var url: String {
    get {return _url ?? String()}
    set {_url = newValue}
  }
  /// Returns true if `url` has been explicitly set.
  var hasURL: Bool {return self._url != nil}
  /// Clears the value of `url`. Subsequent reads from it will return its default value.
  mutating func clearURL() {self._url = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Flags: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case voiceMessage // = 1

    init() {
      self = .voiceMessage
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 1: self = .voiceMessage
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .voiceMessage: return 1
      }
    }

  }

  init() {}

  fileprivate var _id: UInt64? = nil
  fileprivate var _contentType: String? = nil
  fileprivate var _key: Data? = nil
  fileprivate var _size: UInt32? = nil
  fileprivate var _thumbnail: Data? = nil
  fileprivate var _digest: Data? = nil
  fileprivate var _fileName: String? = nil
  fileprivate var _flags: UInt32? = nil
  fileprivate var _width: UInt32? = nil
  fileprivate var _height: UInt32? = nil
  fileprivate var _caption: String? = nil
  fileprivate var _url: String? = nil
}

#if swift(>=4.2)

extension SessionProtos_AttachmentPointer.Flags: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct SessionProtos_GroupContext {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// @required
  var id: Data {
    get {return _storage._id ?? Data()}
    set {_uniqueStorage()._id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return _storage._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {_uniqueStorage()._id = nil}

  /// @required
  var type: SessionProtos_GroupContext.TypeEnum {
    get {return _storage._type ?? .unknown}
    set {_uniqueStorage()._type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return _storage._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {_uniqueStorage()._type = nil}

  var name: String {
    get {return _storage._name ?? String()}
    set {_uniqueStorage()._name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return _storage._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {_uniqueStorage()._name = nil}

  var members: [String] {
    get {return _storage._members}
    set {_uniqueStorage()._members = newValue}
  }

  var avatar: SessionProtos_AttachmentPointer {
    get {return _storage._avatar ?? SessionProtos_AttachmentPointer()}
    set {_uniqueStorage()._avatar = newValue}
  }
  /// Returns true if `avatar` has been explicitly set.
  var hasAvatar: Bool {return _storage._avatar != nil}
  /// Clears the value of `avatar`. Subsequent reads from it will return its default value.
  mutating func clearAvatar() {_uniqueStorage()._avatar = nil}

  var admins: [String] {
    get {return _storage._admins}
    set {_uniqueStorage()._admins = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum TypeEnum: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unknown // = 0
    case update // = 1
    case deliver // = 2
    case quit // = 3
    case requestInfo // = 4

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .update
      case 2: self = .deliver
      case 3: self = .quit
      case 4: self = .requestInfo
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .update: return 1
      case .deliver: return 2
      case .quit: return 3
      case .requestInfo: return 4
      }
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension SessionProtos_GroupContext.TypeEnum: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "SessionProtos"

extension SessionProtos_Envelope: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Envelope"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "source"),
    7: .same(proto: "sourceDevice"),
    5: .same(proto: "timestamp"),
    8: .same(proto: "content"),
    10: .same(proto: "serverTimestamp"),
  ]

  public var isInitialized: Bool {
    if self._type == nil {return false}
    if self._timestamp == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._source) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self._timestamp) }()
      case 7: try { try decoder.decodeSingularUInt32Field(value: &self._sourceDevice) }()
      case 8: try { try decoder.decodeSingularBytesField(value: &self._content) }()
      case 10: try { try decoder.decodeSingularUInt64Field(value: &self._serverTimestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    if let v = self._source {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._timestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 5)
    }
    if let v = self._sourceDevice {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 7)
    }
    if let v = self._content {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 8)
    }
    if let v = self._serverTimestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SessionProtos_Envelope, rhs: SessionProtos_Envelope) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs._source != rhs._source {return false}
    if lhs._sourceDevice != rhs._sourceDevice {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs._content != rhs._content {return false}
    if lhs._serverTimestamp != rhs._serverTimestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SessionProtos_Envelope.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    6: .same(proto: "SESSION_MESSAGE"),
    7: .same(proto: "CLOSED_GROUP_MESSAGE"),
  ]
}

extension SessionProtos_TypingMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TypingMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "timestamp"),
    2: .same(proto: "action"),
  ]

  public var isInitialized: Bool {
    if self._timestamp == nil {return false}
    if self._action == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._timestamp) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._action) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._timestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    }
    if let v = self._action {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SessionProtos_TypingMessage, rhs: SessionProtos_TypingMessage) -> Bool {
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs._action != rhs._action {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SessionProtos_TypingMessage.Action: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STARTED"),
    1: .same(proto: "STOPPED"),
  ]
}

extension SessionProtos_Content: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Content"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dataMessage"),
    5: .same(proto: "receiptMessage"),
    6: .same(proto: "typingMessage"),
    7: .same(proto: "configurationMessage"),
    8: .same(proto: "dataExtractionNotification"),
  ]

  public var isInitialized: Bool {
    if let v = self._dataMessage, !v.isInitialized {return false}
    if let v = self._receiptMessage, !v.isInitialized {return false}
    if let v = self._typingMessage, !v.isInitialized {return false}
    if let v = self._configurationMessage, !v.isInitialized {return false}
    if let v = self._dataExtractionNotification, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._dataMessage) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._receiptMessage) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._typingMessage) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._configurationMessage) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._dataExtractionNotification) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._dataMessage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._receiptMessage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if let v = self._typingMessage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if let v = self._configurationMessage {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    if let v = self._dataExtractionNotification {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SessionProtos_Content, rhs: SessionProtos_Content) -> Bool {
    if lhs._dataMessage != rhs._dataMessage {return false}
    if lhs._receiptMessage != rhs._receiptMessage {return false}
    if lhs._typingMessage != rhs._typingMessage {return false}
    if lhs._configurationMessage != rhs._configurationMessage {return false}
    if lhs._dataExtractionNotification != rhs._dataExtractionNotification {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SessionProtos_CallMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CallMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "offer"),
    2: .same(proto: "answer"),
    3: .same(proto: "iceUpdate"),
    4: .same(proto: "legacyHangup"),
    5: .same(proto: "busy"),
    6: .same(proto: "profileKey"),
    7: .same(proto: "hangup"),
    8: .same(proto: "supportsMultiRing"),
    9: .same(proto: "destinationDeviceId"),
    10: .same(proto: "opaque"),
  ]

  fileprivate class _StorageClass {
    var _offer: SessionProtos_CallMessage.Offer? = nil
    var _answer: SessionProtos_CallMessage.Answer? = nil
    var _iceUpdate: [SessionProtos_CallMessage.IceUpdate] = []
    var _legacyHangup: SessionProtos_CallMessage.Hangup? = nil
    var _busy: SessionProtos_CallMessage.Busy? = nil
    var _profileKey: Data? = nil
    var _hangup: SessionProtos_CallMessage.Hangup? = nil
    var _supportsMultiRing: Bool? = nil
    var _destinationDeviceID: UInt32? = nil
    var _opaque: SessionProtos_CallMessage.Opaque? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _offer = source._offer
      _answer = source._answer
      _iceUpdate = source._iceUpdate
      _legacyHangup = source._legacyHangup
      _busy = source._busy
      _profileKey = source._profileKey
      _hangup = source._hangup
      _supportsMultiRing = source._supportsMultiRing
      _destinationDeviceID = source._destinationDeviceID
      _opaque = source._opaque
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._offer) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._answer) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._iceUpdate) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._legacyHangup) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._busy) }()
        case 6: try { try decoder.decodeSingularBytesField(value: &_storage._profileKey) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._hangup) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._supportsMultiRing) }()
        case 9: try { try decoder.decodeSingularUInt32Field(value: &_storage._destinationDeviceID) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._opaque) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._offer {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._answer {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if !_storage._iceUpdate.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._iceUpdate, fieldNumber: 3)
      }
      if let v = _storage._legacyHangup {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if let v = _storage._busy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if let v = _storage._profileKey {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 6)
      }
      if let v = _storage._hangup {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
      if let v = _storage._supportsMultiRing {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
      }
      if let v = _storage._destinationDeviceID {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 9)
      }
      if let v = _storage._opaque {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SessionProtos_CallMessage, rhs: SessionProtos_CallMessage) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._offer != rhs_storage._offer {return false}
        if _storage._answer != rhs_storage._answer {return false}
        if _storage._iceUpdate != rhs_storage._iceUpdate {return false}
        if _storage._legacyHangup != rhs_storage._legacyHangup {return false}
        if _storage._busy != rhs_storage._busy {return false}
        if _storage._profileKey != rhs_storage._profileKey {return false}
        if _storage._hangup != rhs_storage._hangup {return false}
        if _storage._supportsMultiRing != rhs_storage._supportsMultiRing {return false}
        if _storage._destinationDeviceID != rhs_storage._destinationDeviceID {return false}
        if _storage._opaque != rhs_storage._opaque {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SessionProtos_CallMessage.Offer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SessionProtos_CallMessage.protoMessageName + ".Offer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "sdp"),
    3: .same(proto: "type"),
    4: .same(proto: "opaque"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._sdp) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self._opaque) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._id {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    }
    if let v = self._sdp {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    }
    if let v = self._opaque {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SessionProtos_CallMessage.Offer, rhs: SessionProtos_CallMessage.Offer) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._sdp != rhs._sdp {return false}
    if lhs._type != rhs._type {return false}
    if lhs._opaque != rhs._opaque {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SessionProtos_CallMessage.Offer.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OFFER_AUDIO_CALL"),
    1: .same(proto: "OFFER_VIDEO_CALL"),
  ]
}

extension SessionProtos_CallMessage.Answer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SessionProtos_CallMessage.protoMessageName + ".Answer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "sdp"),
    3: .same(proto: "opaque"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._sdp) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._opaque) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._id {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    }
    if let v = self._sdp {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._opaque {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SessionProtos_CallMessage.Answer, rhs: SessionProtos_CallMessage.Answer) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._sdp != rhs._sdp {return false}
    if lhs._opaque != rhs._opaque {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SessionProtos_CallMessage.IceUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SessionProtos_CallMessage.protoMessageName + ".IceUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "mid"),
    3: .same(proto: "line"),
    4: .same(proto: "sdp"),
    5: .same(proto: "opaque"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._mid) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._line) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._sdp) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self._opaque) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._id {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    }
    if let v = self._mid {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._line {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }
    if let v = self._sdp {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }
    if let v = self._opaque {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SessionProtos_CallMessage.IceUpdate, rhs: SessionProtos_CallMessage.IceUpdate) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._mid != rhs._mid {return false}
    if lhs._line != rhs._line {return false}
    if lhs._sdp != rhs._sdp {return false}
    if lhs._opaque != rhs._opaque {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SessionProtos_CallMessage.Busy: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SessionProtos_CallMessage.protoMessageName + ".Busy"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._id {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SessionProtos_CallMessage.Busy, rhs: SessionProtos_CallMessage.Busy) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SessionProtos_CallMessage.Hangup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SessionProtos_CallMessage.protoMessageName + ".Hangup"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "type"),
    3: .same(proto: "deviceId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._id) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._deviceID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._id {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    }
    if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    }
    if let v = self._deviceID {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SessionProtos_CallMessage.Hangup, rhs: SessionProtos_CallMessage.Hangup) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._type != rhs._type {return false}
    if lhs._deviceID != rhs._deviceID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SessionProtos_CallMessage.Hangup.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "HANGUP_NORMAL"),
    1: .same(proto: "HANGUP_ACCEPTED"),
    2: .same(proto: "HANGUP_DECLINED"),
    3: .same(proto: "HANGUP_BUSY"),
    4: .same(proto: "HANGUP_NEED_PERMISSION"),
  ]
}

extension SessionProtos_CallMessage.Opaque: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SessionProtos_CallMessage.protoMessageName + ".Opaque"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._data {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SessionProtos_CallMessage.Opaque, rhs: SessionProtos_CallMessage.Opaque) -> Bool {
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SessionProtos_KeyPair: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KeyPair"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "publicKey"),
    2: .same(proto: "privateKey"),
  ]

  public var isInitialized: Bool {
    if self._publicKey == nil {return false}
    if self._privateKey == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._publicKey) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._privateKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._publicKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }
    if let v = self._privateKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SessionProtos_KeyPair, rhs: SessionProtos_KeyPair) -> Bool {
    if lhs._publicKey != rhs._publicKey {return false}
    if lhs._privateKey != rhs._privateKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SessionProtos_DataExtractionNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DataExtractionNotification"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "timestamp"),
  ]

  public var isInitialized: Bool {
    if self._type == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self._timestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    if let v = self._timestamp {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SessionProtos_DataExtractionNotification, rhs: SessionProtos_DataExtractionNotification) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs._timestamp != rhs._timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SessionProtos_DataExtractionNotification.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "SCREENSHOT"),
    2: .same(proto: "MEDIA_SAVED"),
  ]
}

extension SessionProtos_DataMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DataMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "body"),
    2: .same(proto: "attachments"),
    3: .same(proto: "group"),
    4: .same(proto: "flags"),
    5: .same(proto: "expireTimer"),
    6: .same(proto: "profileKey"),
    7: .same(proto: "timestamp"),
    8: .same(proto: "quote"),
    10: .same(proto: "preview"),
    19: .same(proto: "groupCallUpdate"),
    101: .same(proto: "profile"),
    102: .same(proto: "openGroupInvitation"),
    104: .same(proto: "closedGroupControlMessage"),
    105: .same(proto: "syncTarget"),
  ]

  fileprivate class _StorageClass {
    var _body: String? = nil
    var _attachments: [SessionProtos_AttachmentPointer] = []
    var _group: SessionProtos_GroupContext? = nil
    var _flags: UInt32? = nil
    var _expireTimer: UInt32? = nil
    var _profileKey: Data? = nil
    var _timestamp: UInt64? = nil
    var _quote: SessionProtos_DataMessage.Quote? = nil
    var _preview: [SessionProtos_DataMessage.Preview] = []
    var _groupCallUpdate: SessionProtos_DataMessage.GroupCallUpdate? = nil
    var _profile: SessionProtos_DataMessage.LokiProfile? = nil
    var _openGroupInvitation: SessionProtos_DataMessage.OpenGroupInvitation? = nil
    var _closedGroupControlMessage: SessionProtos_DataMessage.ClosedGroupControlMessage? = nil
    var _syncTarget: String? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _body = source._body
      _attachments = source._attachments
      _group = source._group
      _flags = source._flags
      _expireTimer = source._expireTimer
      _profileKey = source._profileKey
      _timestamp = source._timestamp
      _quote = source._quote
      _preview = source._preview
      _groupCallUpdate = source._groupCallUpdate
      _profile = source._profile
      _openGroupInvitation = source._openGroupInvitation
      _closedGroupControlMessage = source._closedGroupControlMessage
      _syncTarget = source._syncTarget
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._attachments) {return false}
      if let v = _storage._group, !v.isInitialized {return false}
      if let v = _storage._quote, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._preview) {return false}
      if let v = _storage._openGroupInvitation, !v.isInitialized {return false}
      if let v = _storage._closedGroupControlMessage, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._body) }()
        case 2: try { try decoder.decodeRepeatedMessageField(value: &_storage._attachments) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._group) }()
        case 4: try { try decoder.decodeSingularUInt32Field(value: &_storage._flags) }()
        case 5: try { try decoder.decodeSingularUInt32Field(value: &_storage._expireTimer) }()
        case 6: try { try decoder.decodeSingularBytesField(value: &_storage._profileKey) }()
        case 7: try { try decoder.decodeSingularUInt64Field(value: &_storage._timestamp) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._quote) }()
        case 10: try { try decoder.decodeRepeatedMessageField(value: &_storage._preview) }()
        case 19: try { try decoder.decodeSingularMessageField(value: &_storage._groupCallUpdate) }()
        case 101: try { try decoder.decodeSingularMessageField(value: &_storage._profile) }()
        case 102: try { try decoder.decodeSingularMessageField(value: &_storage._openGroupInvitation) }()
        case 104: try { try decoder.decodeSingularMessageField(value: &_storage._closedGroupControlMessage) }()
        case 105: try { try decoder.decodeSingularStringField(value: &_storage._syncTarget) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._body {
        try visitor.visitSingularStringField(value: v, fieldNumber: 1)
      }
      if !_storage._attachments.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._attachments, fieldNumber: 2)
      }
      if let v = _storage._group {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._flags {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
      }
      if let v = _storage._expireTimer {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
      }
      if let v = _storage._profileKey {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 6)
      }
      if let v = _storage._timestamp {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 7)
      }
      if let v = _storage._quote {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }
      if !_storage._preview.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._preview, fieldNumber: 10)
      }
      if let v = _storage._groupCallUpdate {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      }
      if let v = _storage._profile {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 101)
      }
      if let v = _storage._openGroupInvitation {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 102)
      }
      if let v = _storage._closedGroupControlMessage {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 104)
      }
      if let v = _storage._syncTarget {
        try visitor.visitSingularStringField(value: v, fieldNumber: 105)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SessionProtos_DataMessage, rhs: SessionProtos_DataMessage) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._body != rhs_storage._body {return false}
        if _storage._attachments != rhs_storage._attachments {return false}
        if _storage._group != rhs_storage._group {return false}
        if _storage._flags != rhs_storage._flags {return false}
        if _storage._expireTimer != rhs_storage._expireTimer {return false}
        if _storage._profileKey != rhs_storage._profileKey {return false}
        if _storage._timestamp != rhs_storage._timestamp {return false}
        if _storage._quote != rhs_storage._quote {return false}
        if _storage._preview != rhs_storage._preview {return false}
        if _storage._groupCallUpdate != rhs_storage._groupCallUpdate {return false}
        if _storage._profile != rhs_storage._profile {return false}
        if _storage._openGroupInvitation != rhs_storage._openGroupInvitation {return false}
        if _storage._closedGroupControlMessage != rhs_storage._closedGroupControlMessage {return false}
        if _storage._syncTarget != rhs_storage._syncTarget {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SessionProtos_DataMessage.Flags: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "EXPIRATION_TIMER_UPDATE"),
  ]
}

extension SessionProtos_DataMessage.Quote: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SessionProtos_DataMessage.protoMessageName + ".Quote"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "author"),
    3: .same(proto: "text"),
    4: .same(proto: "attachments"),
  ]

  public var isInitialized: Bool {
    if self._id == nil {return false}
    if self._author == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.attachments) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._author) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._text) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.attachments) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._id {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    }
    if let v = self._author {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._text {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if !self.attachments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.attachments, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SessionProtos_DataMessage.Quote, rhs: SessionProtos_DataMessage.Quote) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._author != rhs._author {return false}
    if lhs._text != rhs._text {return false}
    if lhs.attachments != rhs.attachments {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SessionProtos_DataMessage.Quote.QuotedAttachment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SessionProtos_DataMessage.Quote.protoMessageName + ".QuotedAttachment"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "contentType"),
    2: .same(proto: "fileName"),
    3: .same(proto: "thumbnail"),
    4: .same(proto: "flags"),
  ]

  public var isInitialized: Bool {
    if let v = self._thumbnail, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._contentType) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._fileName) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._thumbnail) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._flags) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._contentType {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._fileName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._thumbnail {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._flags {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SessionProtos_DataMessage.Quote.QuotedAttachment, rhs: SessionProtos_DataMessage.Quote.QuotedAttachment) -> Bool {
    if lhs._contentType != rhs._contentType {return false}
    if lhs._fileName != rhs._fileName {return false}
    if lhs._thumbnail != rhs._thumbnail {return false}
    if lhs._flags != rhs._flags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SessionProtos_DataMessage.Quote.QuotedAttachment.Flags: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "VOICE_MESSAGE"),
  ]
}

extension SessionProtos_DataMessage.Preview: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SessionProtos_DataMessage.protoMessageName + ".Preview"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
    2: .same(proto: "title"),
    3: .same(proto: "image"),
  ]

  public var isInitialized: Bool {
    if self._url == nil {return false}
    if let v = self._image, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._url) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._title) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._image) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._url {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._title {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._image {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SessionProtos_DataMessage.Preview, rhs: SessionProtos_DataMessage.Preview) -> Bool {
    if lhs._url != rhs._url {return false}
    if lhs._title != rhs._title {return false}
    if lhs._image != rhs._image {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SessionProtos_DataMessage.LokiProfile: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SessionProtos_DataMessage.protoMessageName + ".LokiProfile"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "displayName"),
    2: .same(proto: "profilePicture"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._displayName) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._profilePicture) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._displayName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._profilePicture {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SessionProtos_DataMessage.LokiProfile, rhs: SessionProtos_DataMessage.LokiProfile) -> Bool {
    if lhs._displayName != rhs._displayName {return false}
    if lhs._profilePicture != rhs._profilePicture {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SessionProtos_DataMessage.OpenGroupInvitation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SessionProtos_DataMessage.protoMessageName + ".OpenGroupInvitation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
    3: .same(proto: "name"),
  ]

  public var isInitialized: Bool {
    if self._url == nil {return false}
    if self._name == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._url) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._url {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SessionProtos_DataMessage.OpenGroupInvitation, rhs: SessionProtos_DataMessage.OpenGroupInvitation) -> Bool {
    if lhs._url != rhs._url {return false}
    if lhs._name != rhs._name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SessionProtos_DataMessage.ClosedGroupControlMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SessionProtos_DataMessage.protoMessageName + ".ClosedGroupControlMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "publicKey"),
    3: .same(proto: "name"),
    4: .same(proto: "encryptionKeyPair"),
    5: .same(proto: "members"),
    6: .same(proto: "admins"),
    7: .same(proto: "wrappers"),
    8: .same(proto: "expirationTimer"),
  ]

  public var isInitialized: Bool {
    if self._type == nil {return false}
    if let v = self._encryptionKeyPair, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.wrappers) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._publicKey) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._encryptionKeyPair) }()
      case 5: try { try decoder.decodeRepeatedBytesField(value: &self.members) }()
      case 6: try { try decoder.decodeRepeatedBytesField(value: &self.admins) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.wrappers) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self._expirationTimer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    if let v = self._publicKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if let v = self._encryptionKeyPair {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if !self.members.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.members, fieldNumber: 5)
    }
    if !self.admins.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.admins, fieldNumber: 6)
    }
    if !self.wrappers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.wrappers, fieldNumber: 7)
    }
    if let v = self._expirationTimer {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SessionProtos_DataMessage.ClosedGroupControlMessage, rhs: SessionProtos_DataMessage.ClosedGroupControlMessage) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs._publicKey != rhs._publicKey {return false}
    if lhs._name != rhs._name {return false}
    if lhs._encryptionKeyPair != rhs._encryptionKeyPair {return false}
    if lhs.members != rhs.members {return false}
    if lhs.admins != rhs.admins {return false}
    if lhs.wrappers != rhs.wrappers {return false}
    if lhs._expirationTimer != rhs._expirationTimer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SessionProtos_DataMessage.ClosedGroupControlMessage.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "NEW"),
    3: .same(proto: "ENCRYPTION_KEY_PAIR"),
    4: .same(proto: "NAME_CHANGE"),
    5: .same(proto: "MEMBERS_ADDED"),
    6: .same(proto: "MEMBERS_REMOVED"),
    7: .same(proto: "MEMBER_LEFT"),
    8: .same(proto: "ENCRYPTION_KEY_PAIR_REQUEST"),
  ]
}

extension SessionProtos_DataMessage.ClosedGroupControlMessage.KeyPairWrapper: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SessionProtos_DataMessage.ClosedGroupControlMessage.protoMessageName + ".KeyPairWrapper"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "publicKey"),
    2: .same(proto: "encryptedKeyPair"),
  ]

  public var isInitialized: Bool {
    if self._publicKey == nil {return false}
    if self._encryptedKeyPair == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._publicKey) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._encryptedKeyPair) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._publicKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }
    if let v = self._encryptedKeyPair {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SessionProtos_DataMessage.ClosedGroupControlMessage.KeyPairWrapper, rhs: SessionProtos_DataMessage.ClosedGroupControlMessage.KeyPairWrapper) -> Bool {
    if lhs._publicKey != rhs._publicKey {return false}
    if lhs._encryptedKeyPair != rhs._encryptedKeyPair {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SessionProtos_DataMessage.GroupCallUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SessionProtos_DataMessage.protoMessageName + ".GroupCallUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "eraId"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._eraID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._eraID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SessionProtos_DataMessage.GroupCallUpdate, rhs: SessionProtos_DataMessage.GroupCallUpdate) -> Bool {
    if lhs._eraID != rhs._eraID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SessionProtos_ConfigurationMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ConfigurationMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "closedGroups"),
    2: .same(proto: "openGroups"),
    3: .same(proto: "displayName"),
    4: .same(proto: "profilePicture"),
    5: .same(proto: "profileKey"),
    6: .same(proto: "contacts"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.closedGroups) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.contacts) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.closedGroups) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.openGroups) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._displayName) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._profilePicture) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self._profileKey) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.contacts) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.closedGroups.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.closedGroups, fieldNumber: 1)
    }
    if !self.openGroups.isEmpty {
      try visitor.visitRepeatedStringField(value: self.openGroups, fieldNumber: 2)
    }
    if let v = self._displayName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if let v = self._profilePicture {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }
    if let v = self._profileKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 5)
    }
    if !self.contacts.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.contacts, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SessionProtos_ConfigurationMessage, rhs: SessionProtos_ConfigurationMessage) -> Bool {
    if lhs.closedGroups != rhs.closedGroups {return false}
    if lhs.openGroups != rhs.openGroups {return false}
    if lhs._displayName != rhs._displayName {return false}
    if lhs._profilePicture != rhs._profilePicture {return false}
    if lhs._profileKey != rhs._profileKey {return false}
    if lhs.contacts != rhs.contacts {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SessionProtos_ConfigurationMessage.ClosedGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SessionProtos_ConfigurationMessage.protoMessageName + ".ClosedGroup"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "publicKey"),
    2: .same(proto: "name"),
    3: .same(proto: "encryptionKeyPair"),
    4: .same(proto: "members"),
    5: .same(proto: "admins"),
    6: .same(proto: "expirationTimer"),
  ]

  public var isInitialized: Bool {
    if let v = self._encryptionKeyPair, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._publicKey) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._encryptionKeyPair) }()
      case 4: try { try decoder.decodeRepeatedBytesField(value: &self.members) }()
      case 5: try { try decoder.decodeRepeatedBytesField(value: &self.admins) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self._expirationTimer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._publicKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._encryptionKeyPair {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.members.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.members, fieldNumber: 4)
    }
    if !self.admins.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.admins, fieldNumber: 5)
    }
    if let v = self._expirationTimer {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SessionProtos_ConfigurationMessage.ClosedGroup, rhs: SessionProtos_ConfigurationMessage.ClosedGroup) -> Bool {
    if lhs._publicKey != rhs._publicKey {return false}
    if lhs._name != rhs._name {return false}
    if lhs._encryptionKeyPair != rhs._encryptionKeyPair {return false}
    if lhs.members != rhs.members {return false}
    if lhs.admins != rhs.admins {return false}
    if lhs._expirationTimer != rhs._expirationTimer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SessionProtos_ConfigurationMessage.Contact: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = SessionProtos_ConfigurationMessage.protoMessageName + ".Contact"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "publicKey"),
    2: .same(proto: "name"),
    3: .same(proto: "profilePicture"),
    4: .same(proto: "profileKey"),
  ]

  public var isInitialized: Bool {
    if self._publicKey == nil {return false}
    if self._name == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._publicKey) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._profilePicture) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self._profileKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._publicKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }
    if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._profilePicture {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    }
    if let v = self._profileKey {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SessionProtos_ConfigurationMessage.Contact, rhs: SessionProtos_ConfigurationMessage.Contact) -> Bool {
    if lhs._publicKey != rhs._publicKey {return false}
    if lhs._name != rhs._name {return false}
    if lhs._profilePicture != rhs._profilePicture {return false}
    if lhs._profileKey != rhs._profileKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SessionProtos_ReceiptMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReceiptMessage"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "timestamp"),
  ]

  public var isInitialized: Bool {
    if self._type == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 2: try { try decoder.decodeRepeatedUInt64Field(value: &self.timestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    }
    if !self.timestamp.isEmpty {
      try visitor.visitRepeatedUInt64Field(value: self.timestamp, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SessionProtos_ReceiptMessage, rhs: SessionProtos_ReceiptMessage) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SessionProtos_ReceiptMessage.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DELIVERY"),
    1: .same(proto: "READ"),
  ]
}

extension SessionProtos_AttachmentPointer: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AttachmentPointer"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "contentType"),
    3: .same(proto: "key"),
    4: .same(proto: "size"),
    5: .same(proto: "thumbnail"),
    6: .same(proto: "digest"),
    7: .same(proto: "fileName"),
    8: .same(proto: "flags"),
    9: .same(proto: "width"),
    10: .same(proto: "height"),
    11: .same(proto: "caption"),
    101: .same(proto: "url"),
  ]

  public var isInitialized: Bool {
    if self._id == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed64Field(value: &self._id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._contentType) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._key) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._size) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self._thumbnail) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self._digest) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._fileName) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self._flags) }()
      case 9: try { try decoder.decodeSingularUInt32Field(value: &self._width) }()
      case 10: try { try decoder.decodeSingularUInt32Field(value: &self._height) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self._caption) }()
      case 101: try { try decoder.decodeSingularStringField(value: &self._url) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._id {
      try visitor.visitSingularFixed64Field(value: v, fieldNumber: 1)
    }
    if let v = self._contentType {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    }
    if let v = self._key {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    }
    if let v = self._size {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    }
    if let v = self._thumbnail {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 5)
    }
    if let v = self._digest {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 6)
    }
    if let v = self._fileName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    }
    if let v = self._flags {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 8)
    }
    if let v = self._width {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 9)
    }
    if let v = self._height {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 10)
    }
    if let v = self._caption {
      try visitor.visitSingularStringField(value: v, fieldNumber: 11)
    }
    if let v = self._url {
      try visitor.visitSingularStringField(value: v, fieldNumber: 101)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SessionProtos_AttachmentPointer, rhs: SessionProtos_AttachmentPointer) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._contentType != rhs._contentType {return false}
    if lhs._key != rhs._key {return false}
    if lhs._size != rhs._size {return false}
    if lhs._thumbnail != rhs._thumbnail {return false}
    if lhs._digest != rhs._digest {return false}
    if lhs._fileName != rhs._fileName {return false}
    if lhs._flags != rhs._flags {return false}
    if lhs._width != rhs._width {return false}
    if lhs._height != rhs._height {return false}
    if lhs._caption != rhs._caption {return false}
    if lhs._url != rhs._url {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SessionProtos_AttachmentPointer.Flags: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "VOICE_MESSAGE"),
  ]
}

extension SessionProtos_GroupContext: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GroupContext"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "type"),
    3: .same(proto: "name"),
    4: .same(proto: "members"),
    5: .same(proto: "avatar"),
    6: .same(proto: "admins"),
  ]

  fileprivate class _StorageClass {
    var _id: Data? = nil
    var _type: SessionProtos_GroupContext.TypeEnum? = nil
    var _name: String? = nil
    var _members: [String] = []
    var _avatar: SessionProtos_AttachmentPointer? = nil
    var _admins: [String] = []

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _type = source._type
      _name = source._name
      _members = source._members
      _avatar = source._avatar
      _admins = source._admins
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._avatar, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBytesField(value: &_storage._id) }()
        case 2: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._name) }()
        case 4: try { try decoder.decodeRepeatedStringField(value: &_storage._members) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._avatar) }()
        case 6: try { try decoder.decodeRepeatedStringField(value: &_storage._admins) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._id {
        try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
      }
      if let v = _storage._type {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
      }
      if let v = _storage._name {
        try visitor.visitSingularStringField(value: v, fieldNumber: 3)
      }
      if !_storage._members.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._members, fieldNumber: 4)
      }
      if let v = _storage._avatar {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
      if !_storage._admins.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._admins, fieldNumber: 6)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SessionProtos_GroupContext, rhs: SessionProtos_GroupContext) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._type != rhs_storage._type {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._members != rhs_storage._members {return false}
        if _storage._avatar != rhs_storage._avatar {return false}
        if _storage._admins != rhs_storage._admins {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SessionProtos_GroupContext.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "UPDATE"),
    2: .same(proto: "DELIVER"),
    3: .same(proto: "QUIT"),
    4: .same(proto: "REQUEST_INFO"),
  ]
}
